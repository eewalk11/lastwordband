import { mockAlbumFactory } from './AlbumFactory.mock';
import AlbumService from './AlbumService';
import InvalidAlbumTitleError from './InvalidAlbumTitleError';
import SalesLinksNotFoundError from './SalesLinksNotFoundError';
import { HALLS_OF_MADNESS } from 'app/const';
import { Album } from 'app/domain';
import { chance } from 'app/util';

const setup = (overrides = {}) => {
  const args = {
    albumFactories: [mockAlbumFactory(), mockAlbumFactory(), mockAlbumFactory()]
  };
  return new AlbumService({ ...args, ...overrides });
};

describe('AlbumService unit tests', () => {
  describe('get albums', () => {
    it('Returns each album generated by an album factory', () => {
      // Generate fixed titles
      const albumFactories = [
        mockAlbumFactory({ title: chance.string() }),
        mockAlbumFactory({ title: chance.string() }),
        mockAlbumFactory({ title: chance.string() })
      ];
      const subject = setup({ albumFactories });

      const result = subject.albums;
      expect(result).toHaveLength(subject.albumFactories.length);
      result.forEach((album, i) => {
        const expectedTitle = subject.albumFactories[i].newAlbum().title;
        expect(album.title).toBe(expectedTitle);
      });
    });

    it('Memoizes the result', () => {
      const subject = setup();
      const result1 = subject.albums;
      const result2 = subject.albums;
      expect(result1).toBe(result2);
    });
  });

  describe('findByTitle()', () => {
    let subject;
    let expectedAlbum;

    beforeEach(() => {
      // Generate albums with predictable titles
      const albumFactories = [
        mockAlbumFactory({ title: 'Album X' }),
        mockAlbumFactory({ title: 'Test Title' }),
        mockAlbumFactory({ title: 'Album Y' })
      ];
      subject = setup({ albumFactories });
      expectedAlbum = subject.albums[1];
    });

    it('Finds an album by its title', () => {
      const result = subject.findByTitle({
        title: 'Test Title',
        isCamelCase: false
      });
      expect(result).toBe(expectedAlbum);
    });

    it('Finds an album by camelCase title', () => {
      const result = subject.findByTitle({ title: 'testTitle' });
      expect(result).toBe(expectedAlbum);
    });

    it('Throws an InvalidAlbumTitleError if the album cannot be found', () => {
      const test = () => subject.findByTitle({ title: 'invalid' });
      expect(test).toThrow(InvalidAlbumTitleError);
    });
  });

  describe('getSalesLinks()', () => {
    it('Returns sales links for a valid album', () => {
      const subject = setup();
      const album = new Album({ title: HALLS_OF_MADNESS });
      const result = subject.getSalesLinks(album);
      expect(result).toBeDefined();
    });

    it('Throws a SalesLinksNotFoundError if there are no sales links configured for the album', () => {
      const subject = setup();
      const album = new Album({ title: 'invalid' });
      const test = () => subject.getSalesLinks(album);
      expect(test).toThrow(SalesLinksNotFoundError);
    });
  });

  describe('sortByDate()', () => {
    let subject;
    let album1, album2, album3;

    beforeEach(() => {
      // Set dates in a predictable order
      const date1 = new Date('2000-01-01');
      const date2 = new Date('2000-01-02');
      const date3 = new Date('2000-01-03');

      // Generate albums with dates out of order
      const albumFactories = [
        mockAlbumFactory({ date: date2 }),
        mockAlbumFactory({ date: date3 }),
        mockAlbumFactory({ date: date1 })
      ];
      subject = setup({ albumFactories });

      // Album numbers should match date numbers
      [album2, album3, album1] = subject.albums;
    });

    it('Correctly sorts albums in ascending order', () => {
      const result = subject.sortByDate({ desc: false });
      expect(result).toEqual([album1, album2, album3]);
    });

    it('Correctly sorts albums in descending order', () => {
      const result = subject.sortByDate();
      expect(result).toEqual([album3, album2, album1]);
    });

    it('Does not modify the source array', () => {
      const result = subject.sortByDate();
      expect(result).not.toEqual(subject.albums);
    });

    it('Does nothing with an empty array of albums', () => {
      const result = subject.sortByDate({ albums: [] });
      expect(result).toEqual([]);
    });
  });
});
